{
  "version": 3,
  "sources": ["../../html-to-image/src/util.ts", "../../html-to-image/src/clone-pseudos.ts", "../../html-to-image/src/mimes.ts", "../../html-to-image/src/dataurl.ts", "../../html-to-image/src/clone-node.ts", "../../html-to-image/src/embed-resources.ts", "../../html-to-image/src/embed-images.ts", "../../html-to-image/src/apply-style.ts", "../../html-to-image/src/embed-webfonts.ts", "../../html-to-image/src/index.ts"],
  "sourcesContent": ["import type { Options } from './types'\r\n\r\nexport function resolveUrl(url: string, baseUrl: string | null): string {\r\n  // url is absolute already\r\n  if (url.match(/^[a-z]+:\\/\\//i)) {\r\n    return url\r\n  }\r\n\r\n  // url is absolute already, without protocol\r\n  if (url.match(/^\\/\\//)) {\r\n    return window.location.protocol + url\r\n  }\r\n\r\n  // dataURI, mailto:, tel:, etc.\r\n  if (url.match(/^[a-z]+:/i)) {\r\n    return url\r\n  }\r\n\r\n  const doc = document.implementation.createHTMLDocument()\r\n  const base = doc.createElement('base')\r\n  const a = doc.createElement('a')\r\n\r\n  doc.head.appendChild(base)\r\n  doc.body.appendChild(a)\r\n\r\n  if (baseUrl) {\r\n    base.href = baseUrl\r\n  }\r\n\r\n  a.href = url\r\n\r\n  return a.href\r\n}\r\n\r\nexport const uuid = (() => {\r\n  // generate uuid for className of pseudo elements.\r\n  // We should not use GUIDs, otherwise pseudo elements sometimes cannot be captured.\r\n  let counter = 0\r\n\r\n  // ref: http://stackoverflow.com/a/6248722/2519373\r\n  const random = () =>\r\n    // eslint-disable-next-line no-bitwise\r\n    `0000${((Math.random() * 36 ** 4) << 0).toString(36)}`.slice(-4)\r\n\r\n  return () => {\r\n    counter += 1\r\n    return `u${random()}${counter}`\r\n  }\r\n})()\r\n\r\nexport function delay<T>(ms: number) {\r\n  return (args: T) =>\r\n    new Promise<T>((resolve) => {\r\n      setTimeout(() => resolve(args), ms)\r\n    })\r\n}\r\n\r\nexport function toArray<T>(arrayLike: any): T[] {\r\n  const arr: T[] = []\r\n\r\n  for (let i = 0, l = arrayLike.length; i < l; i++) {\r\n    arr.push(arrayLike[i])\r\n  }\r\n\r\n  return arr\r\n}\r\n\r\nlet styleProps: string[] | null = null\r\nexport function getStyleProperties(options: Options = {}): string[] {\r\n  if (styleProps) {\r\n    return styleProps\r\n  }\r\n\r\n  if (options.includeStyleProperties) {\r\n    styleProps = options.includeStyleProperties\r\n    return styleProps\r\n  }\r\n\r\n  styleProps = toArray(window.getComputedStyle(document.documentElement))\r\n\r\n  return styleProps\r\n}\r\n\r\nfunction px(node: HTMLElement, styleProperty: string) {\r\n  const win = node.ownerDocument.defaultView || window\r\n  const val = win.getComputedStyle(node).getPropertyValue(styleProperty)\r\n  return val ? parseFloat(val.replace('px', '')) : 0\r\n}\r\n\r\nfunction getNodeWidth(node: HTMLElement) {\r\n  const leftBorder = px(node, 'border-left-width')\r\n  const rightBorder = px(node, 'border-right-width')\r\n  return node.clientWidth + leftBorder + rightBorder\r\n}\r\n\r\nfunction getNodeHeight(node: HTMLElement) {\r\n  const topBorder = px(node, 'border-top-width')\r\n  const bottomBorder = px(node, 'border-bottom-width')\r\n  return node.clientHeight + topBorder + bottomBorder\r\n}\r\n\r\nexport function getImageSize(targetNode: HTMLElement, options: Options = {}) {\r\n  const width = options.width || getNodeWidth(targetNode)\r\n  const height = options.height || getNodeHeight(targetNode)\r\n\r\n  return { width, height }\r\n}\r\n\r\nexport function getPixelRatio() {\r\n  let ratio\r\n\r\n  let FINAL_PROCESS\r\n  try {\r\n    FINAL_PROCESS = process\r\n  } catch (e) {\r\n    // pass\r\n  }\r\n\r\n  const val =\r\n    FINAL_PROCESS && FINAL_PROCESS.env\r\n      ? FINAL_PROCESS.env.devicePixelRatio\r\n      : null\r\n  if (val) {\r\n    ratio = parseInt(val, 10)\r\n    if (Number.isNaN(ratio)) {\r\n      ratio = 1\r\n    }\r\n  }\r\n  return ratio || window.devicePixelRatio || 1\r\n}\r\n\r\n// @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas#maximum_canvas_size\r\nconst canvasDimensionLimit = 16384\r\n\r\nexport function checkCanvasDimensions(canvas: HTMLCanvasElement) {\r\n  if (\r\n    canvas.width > canvasDimensionLimit ||\r\n    canvas.height > canvasDimensionLimit\r\n  ) {\r\n    if (\r\n      canvas.width > canvasDimensionLimit &&\r\n      canvas.height > canvasDimensionLimit\r\n    ) {\r\n      if (canvas.width > canvas.height) {\r\n        canvas.height *= canvasDimensionLimit / canvas.width\r\n        canvas.width = canvasDimensionLimit\r\n      } else {\r\n        canvas.width *= canvasDimensionLimit / canvas.height\r\n        canvas.height = canvasDimensionLimit\r\n      }\r\n    } else if (canvas.width > canvasDimensionLimit) {\r\n      canvas.height *= canvasDimensionLimit / canvas.width\r\n      canvas.width = canvasDimensionLimit\r\n    } else {\r\n      canvas.width *= canvasDimensionLimit / canvas.height\r\n      canvas.height = canvasDimensionLimit\r\n    }\r\n  }\r\n}\r\n\r\nexport function canvasToBlob(\r\n  canvas: HTMLCanvasElement,\r\n  options: Options = {},\r\n): Promise<Blob | null> {\r\n  if (canvas.toBlob) {\r\n    return new Promise((resolve) => {\r\n      canvas.toBlob(\r\n        resolve,\r\n        options.type ? options.type : 'image/png',\r\n        options.quality ? options.quality : 1,\r\n      )\r\n    })\r\n  }\r\n\r\n  return new Promise((resolve) => {\r\n    const binaryString = window.atob(\r\n      canvas\r\n        .toDataURL(\r\n          options.type ? options.type : undefined,\r\n          options.quality ? options.quality : undefined,\r\n        )\r\n        .split(',')[1],\r\n    )\r\n    const len = binaryString.length\r\n    const binaryArray = new Uint8Array(len)\r\n\r\n    for (let i = 0; i < len; i += 1) {\r\n      binaryArray[i] = binaryString.charCodeAt(i)\r\n    }\r\n\r\n    resolve(\r\n      new Blob([binaryArray], {\r\n        type: options.type ? options.type : 'image/png',\r\n      }),\r\n    )\r\n  })\r\n}\r\n\r\nexport function createImage(url: string): Promise<HTMLImageElement> {\r\n  return new Promise((resolve, reject) => {\r\n    const img = new Image()\r\n    img.onload = () => {\r\n      img.decode().then(() => {\r\n        requestAnimationFrame(() => resolve(img))\r\n      })\r\n    }\r\n    img.onerror = reject\r\n    img.crossOrigin = 'anonymous'\r\n    img.decoding = 'async'\r\n    img.src = url\r\n  })\r\n}\r\n\r\nexport async function svgToDataURL(svg: SVGElement): Promise<string> {\r\n  return Promise.resolve()\r\n    .then(() => new XMLSerializer().serializeToString(svg))\r\n    .then(encodeURIComponent)\r\n    .then((html) => `data:image/svg+xml;charset=utf-8,${html}`)\r\n}\r\n\r\nexport async function nodeToDataURL(\r\n  node: HTMLElement,\r\n  width: number,\r\n  height: number,\r\n): Promise<string> {\r\n  const xmlns = 'http://www.w3.org/2000/svg'\r\n  const svg = document.createElementNS(xmlns, 'svg')\r\n  const foreignObject = document.createElementNS(xmlns, 'foreignObject')\r\n\r\n  svg.setAttribute('width', `${width}`)\r\n  svg.setAttribute('height', `${height}`)\r\n  svg.setAttribute('viewBox', `0 0 ${width} ${height}`)\r\n\r\n  foreignObject.setAttribute('width', '100%')\r\n  foreignObject.setAttribute('height', '100%')\r\n  foreignObject.setAttribute('x', '0')\r\n  foreignObject.setAttribute('y', '0')\r\n  foreignObject.setAttribute('externalResourcesRequired', 'true')\r\n\r\n  svg.appendChild(foreignObject)\r\n  foreignObject.appendChild(node)\r\n  return svgToDataURL(svg)\r\n}\r\n\r\nexport const isInstanceOfElement = <\r\n  T extends typeof Element | typeof HTMLElement | typeof SVGImageElement,\r\n>(\r\n  node: Element | HTMLElement | SVGImageElement,\r\n  instance: T,\r\n): node is T['prototype'] => {\r\n  if (node instanceof instance) return true\r\n\r\n  const nodePrototype = Object.getPrototypeOf(node)\r\n\r\n  if (nodePrototype === null) return false\r\n\r\n  return (\r\n    nodePrototype.constructor.name === instance.name ||\r\n    isInstanceOfElement(nodePrototype, instance)\r\n  )\r\n}\r\n", "import type { Options } from './types'\r\nimport { uuid, getStyleProperties } from './util'\r\n\r\ntype Pseudo = ':before' | ':after'\r\n\r\nfunction formatCSSText(style: CSSStyleDeclaration) {\r\n  const content = style.getPropertyValue('content')\r\n  return `${style.cssText} content: '${content.replace(/'|\"/g, '')}';`\r\n}\r\n\r\nfunction formatCSSProperties(style: CSSStyleDeclaration, options: Options) {\r\n  return getStyleProperties(options)\r\n    .map((name) => {\r\n      const value = style.getPropertyValue(name)\r\n      const priority = style.getPropertyPriority(name)\r\n\r\n      return `${name}: ${value}${priority ? ' !important' : ''};`\r\n    })\r\n    .join(' ')\r\n}\r\n\r\nfunction getPseudoElementStyle(\r\n  className: string,\r\n  pseudo: Pseudo,\r\n  style: CSSStyleDeclaration,\r\n  options: Options,\r\n): Text {\r\n  const selector = `.${className}:${pseudo}`\r\n  const cssText = style.cssText\r\n    ? formatCSSText(style)\r\n    : formatCSSProperties(style, options)\r\n\r\n  return document.createTextNode(`${selector}{${cssText}}`)\r\n}\r\n\r\nfunction clonePseudoElement<T extends HTMLElement>(\r\n  nativeNode: T,\r\n  clonedNode: T,\r\n  pseudo: Pseudo,\r\n  options: Options,\r\n) {\r\n  const style = window.getComputedStyle(nativeNode, pseudo)\r\n  const content = style.getPropertyValue('content')\r\n  if (content === '' || content === 'none') {\r\n    return\r\n  }\r\n\r\n  const className = uuid()\r\n  try {\r\n    clonedNode.className = `${clonedNode.className} ${className}`\r\n  } catch (err) {\r\n    return\r\n  }\r\n\r\n  const styleElement = document.createElement('style')\r\n  styleElement.appendChild(\r\n    getPseudoElementStyle(className, pseudo, style, options),\r\n  )\r\n  clonedNode.appendChild(styleElement)\r\n}\r\n\r\nexport function clonePseudoElements<T extends HTMLElement>(\r\n  nativeNode: T,\r\n  clonedNode: T,\r\n  options: Options,\r\n) {\r\n  clonePseudoElement(nativeNode, clonedNode, ':before', options)\r\n  clonePseudoElement(nativeNode, clonedNode, ':after', options)\r\n}\r\n", "const WOFF = 'application/font-woff'\r\nconst JPEG = 'image/jpeg'\r\nconst mimes: { [key: string]: string } = {\r\n  woff: WOFF,\r\n  woff2: WOFF,\r\n  ttf: 'application/font-truetype',\r\n  eot: 'application/vnd.ms-fontobject',\r\n  png: 'image/png',\r\n  jpg: JPEG,\r\n  jpeg: JPEG,\r\n  gif: 'image/gif',\r\n  tiff: 'image/tiff',\r\n  svg: 'image/svg+xml',\r\n  webp: 'image/webp',\r\n}\r\n\r\nfunction getExtension(url: string): string {\r\n  const match = /\\.([^./]*?)$/g.exec(url)\r\n  return match ? match[1] : ''\r\n}\r\n\r\nexport function getMimeType(url: string): string {\r\n  const extension = getExtension(url).toLowerCase()\r\n  return mimes[extension] || ''\r\n}\r\n", "import { Options } from './types'\r\n\r\nfunction getContentFromDataUrl(dataURL: string) {\r\n  return dataURL.split(/,/)[1]\r\n}\r\n\r\nexport function isDataUrl(url: string) {\r\n  return url.search(/^(data:)/) !== -1\r\n}\r\n\r\nexport function makeDataUrl(content: string, mimeType: string) {\r\n  return `data:${mimeType};base64,${content}`\r\n}\r\n\r\nexport async function fetchAsDataURL<T>(\r\n  url: string,\r\n  init: RequestInit | undefined,\r\n  process: (data: { result: string; res: Response }) => T,\r\n): Promise<T> {\r\n  const res = await fetch(url, init)\r\n  if (res.status === 404) {\r\n    throw new Error(`Resource \"${res.url}\" not found`)\r\n  }\r\n  const blob = await res.blob()\r\n  return new Promise<T>((resolve, reject) => {\r\n    const reader = new FileReader()\r\n    reader.onerror = reject\r\n    reader.onloadend = () => {\r\n      try {\r\n        resolve(process({ res, result: reader.result as string }))\r\n      } catch (error) {\r\n        reject(error)\r\n      }\r\n    }\r\n\r\n    reader.readAsDataURL(blob)\r\n  })\r\n}\r\n\r\nconst cache: { [url: string]: string } = {}\r\n\r\nfunction getCacheKey(\r\n  url: string,\r\n  contentType: string | undefined,\r\n  includeQueryParams: boolean | undefined,\r\n) {\r\n  let key = url.replace(/\\?.*/, '')\r\n\r\n  if (includeQueryParams) {\r\n    key = url\r\n  }\r\n\r\n  // font resource\r\n  if (/ttf|otf|eot|woff2?/i.test(key)) {\r\n    key = key.replace(/.*\\//, '')\r\n  }\r\n\r\n  return contentType ? `[${contentType}]${key}` : key\r\n}\r\n\r\nexport async function resourceToDataURL(\r\n  resourceUrl: string,\r\n  contentType: string | undefined,\r\n  options: Options,\r\n) {\r\n  const cacheKey = getCacheKey(\r\n    resourceUrl,\r\n    contentType,\r\n    options.includeQueryParams,\r\n  )\r\n\r\n  if (cache[cacheKey] != null) {\r\n    return cache[cacheKey]\r\n  }\r\n\r\n  // ref: https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Bypassing_the_cache\r\n  if (options.cacheBust) {\r\n    // eslint-disable-next-line no-param-reassign\r\n    resourceUrl += (/\\?/.test(resourceUrl) ? '&' : '?') + new Date().getTime()\r\n  }\r\n\r\n  let dataURL: string\r\n  try {\r\n    const content = await fetchAsDataURL(\r\n      resourceUrl,\r\n      options.fetchRequestInit,\r\n      ({ res, result }) => {\r\n        if (!contentType) {\r\n          // eslint-disable-next-line no-param-reassign\r\n          contentType = res.headers.get('Content-Type') || ''\r\n        }\r\n        return getContentFromDataUrl(result)\r\n      },\r\n    )\r\n    dataURL = makeDataUrl(content, contentType!)\r\n  } catch (error) {\r\n    dataURL = options.imagePlaceholder || ''\r\n\r\n    let msg = `Failed to fetch resource: ${resourceUrl}`\r\n    if (error) {\r\n      msg = typeof error === 'string' ? error : error.message\r\n    }\r\n\r\n    if (msg) {\r\n      console.warn(msg)\r\n    }\r\n  }\r\n\r\n  cache[cacheKey] = dataURL\r\n  return dataURL\r\n}\r\n", "import type { Options } from './types'\r\nimport { clonePseudoElements } from './clone-pseudos'\r\nimport {\r\n  createImage,\r\n  toArray,\r\n  isInstanceOfElement,\r\n  getStyleProperties,\r\n} from './util'\r\nimport { getMimeType } from './mimes'\r\nimport { resourceToDataURL } from './dataurl'\r\n\r\nasync function cloneCanvasElement(canvas: HTMLCanvasElement) {\r\n  const dataURL = canvas.toDataURL()\r\n  if (dataURL === 'data:,') {\r\n    return canvas.cloneNode(false) as HTMLCanvasElement\r\n  }\r\n  return createImage(dataURL)\r\n}\r\n\r\nasync function cloneVideoElement(video: HTMLVideoElement, options: Options) {\r\n  if (video.currentSrc) {\r\n    const canvas = document.createElement('canvas')\r\n    const ctx = canvas.getContext('2d')\r\n    canvas.width = video.clientWidth\r\n    canvas.height = video.clientHeight\r\n    ctx?.drawImage(video, 0, 0, canvas.width, canvas.height)\r\n    const dataURL = canvas.toDataURL()\r\n    return createImage(dataURL)\r\n  }\r\n\r\n  const poster = video.poster\r\n  const contentType = getMimeType(poster)\r\n  const dataURL = await resourceToDataURL(poster, contentType, options)\r\n  return createImage(dataURL)\r\n}\r\n\r\nasync function cloneIFrameElement(iframe: HTMLIFrameElement, options: Options) {\r\n  try {\r\n    if (iframe?.contentDocument?.body) {\r\n      return (await cloneNode(\r\n        iframe.contentDocument.body,\r\n        options,\r\n        true,\r\n      )) as HTMLBodyElement\r\n    }\r\n  } catch {\r\n    // Failed to clone iframe\r\n  }\r\n\r\n  return iframe.cloneNode(false) as HTMLIFrameElement\r\n}\r\n\r\nasync function cloneSingleNode<T extends HTMLElement>(\r\n  node: T,\r\n  options: Options,\r\n): Promise<HTMLElement> {\r\n  if (isInstanceOfElement(node, HTMLCanvasElement)) {\r\n    return cloneCanvasElement(node)\r\n  }\r\n\r\n  if (isInstanceOfElement(node, HTMLVideoElement)) {\r\n    return cloneVideoElement(node, options)\r\n  }\r\n\r\n  if (isInstanceOfElement(node, HTMLIFrameElement)) {\r\n    return cloneIFrameElement(node, options)\r\n  }\r\n\r\n  return node.cloneNode(isSVGElement(node)) as T\r\n}\r\n\r\nconst isSlotElement = (node: HTMLElement): node is HTMLSlotElement =>\r\n  node.tagName != null && node.tagName.toUpperCase() === 'SLOT'\r\n\r\nconst isSVGElement = (node: HTMLElement): node is HTMLSlotElement =>\r\n  node.tagName != null && node.tagName.toUpperCase() === 'SVG'\r\n\r\nasync function cloneChildren<T extends HTMLElement>(\r\n  nativeNode: T,\r\n  clonedNode: T,\r\n  options: Options,\r\n): Promise<T> {\r\n  if (isSVGElement(clonedNode)) {\r\n    return clonedNode\r\n  }\r\n\r\n  let children: T[] = []\r\n\r\n  if (isSlotElement(nativeNode) && nativeNode.assignedNodes) {\r\n    children = toArray<T>(nativeNode.assignedNodes())\r\n  } else if (\r\n    isInstanceOfElement(nativeNode, HTMLIFrameElement) &&\r\n    nativeNode.contentDocument?.body\r\n  ) {\r\n    children = toArray<T>(nativeNode.contentDocument.body.childNodes)\r\n  } else {\r\n    children = toArray<T>((nativeNode.shadowRoot ?? nativeNode).childNodes)\r\n  }\r\n\r\n  if (\r\n    children.length === 0 ||\r\n    isInstanceOfElement(nativeNode, HTMLVideoElement)\r\n  ) {\r\n    return clonedNode\r\n  }\r\n\r\n  await children.reduce(\r\n    (deferred, child) =>\r\n      deferred\r\n        .then(() => cloneNode(child, options))\r\n        .then((clonedChild: HTMLElement | null) => {\r\n          if (clonedChild) {\r\n            clonedNode.appendChild(clonedChild)\r\n          }\r\n        }),\r\n    Promise.resolve(),\r\n  )\r\n\r\n  return clonedNode\r\n}\r\n\r\nfunction cloneCSSStyle<T extends HTMLElement>(\r\n  nativeNode: T,\r\n  clonedNode: T,\r\n  options: Options,\r\n) {\r\n  const targetStyle = clonedNode.style\r\n  if (!targetStyle) {\r\n    return\r\n  }\r\n\r\n  const sourceStyle = window.getComputedStyle(nativeNode)\r\n  if (sourceStyle.cssText) {\r\n    targetStyle.cssText = sourceStyle.cssText\r\n    targetStyle.transformOrigin = sourceStyle.transformOrigin\r\n  } else {\r\n    getStyleProperties(options).forEach((name) => {\r\n      let value = sourceStyle.getPropertyValue(name)\r\n      if (name === 'font-size' && value.endsWith('px')) {\r\n        const reducedFont =\r\n          Math.floor(parseFloat(value.substring(0, value.length - 2))) - 0.1\r\n        value = `${reducedFont}px`\r\n      }\r\n\r\n      if (\r\n        isInstanceOfElement(nativeNode, HTMLIFrameElement) &&\r\n        name === 'display' &&\r\n        value === 'inline'\r\n      ) {\r\n        value = 'block'\r\n      }\r\n\r\n      if (name === 'd' && clonedNode.getAttribute('d')) {\r\n        value = `path(${clonedNode.getAttribute('d')})`\r\n      }\r\n\r\n      targetStyle.setProperty(\r\n        name,\r\n        value,\r\n        sourceStyle.getPropertyPriority(name),\r\n      )\r\n    })\r\n  }\r\n}\r\n\r\nfunction cloneInputValue<T extends HTMLElement>(nativeNode: T, clonedNode: T) {\r\n  if (isInstanceOfElement(nativeNode, HTMLTextAreaElement)) {\r\n    clonedNode.innerHTML = nativeNode.value\r\n  }\r\n\r\n  if (isInstanceOfElement(nativeNode, HTMLInputElement)) {\r\n    clonedNode.setAttribute('value', nativeNode.value)\r\n  }\r\n}\r\n\r\nfunction cloneSelectValue<T extends HTMLElement>(nativeNode: T, clonedNode: T) {\r\n  if (isInstanceOfElement(nativeNode, HTMLSelectElement)) {\r\n    const clonedSelect = clonedNode as any as HTMLSelectElement\r\n    const selectedOption = Array.from(clonedSelect.children).find(\r\n      (child) => nativeNode.value === child.getAttribute('value'),\r\n    )\r\n\r\n    if (selectedOption) {\r\n      selectedOption.setAttribute('selected', '')\r\n    }\r\n  }\r\n}\r\n\r\nfunction decorate<T extends HTMLElement>(\r\n  nativeNode: T,\r\n  clonedNode: T,\r\n  options: Options,\r\n): T {\r\n  if (isInstanceOfElement(clonedNode, Element)) {\r\n    cloneCSSStyle(nativeNode, clonedNode, options)\r\n    clonePseudoElements(nativeNode, clonedNode, options)\r\n    cloneInputValue(nativeNode, clonedNode)\r\n    cloneSelectValue(nativeNode, clonedNode)\r\n  }\r\n\r\n  return clonedNode\r\n}\r\n\r\nasync function ensureSVGSymbols<T extends HTMLElement>(\r\n  clone: T,\r\n  options: Options,\r\n) {\r\n  const uses = clone.querySelectorAll ? clone.querySelectorAll('use') : []\r\n  if (uses.length === 0) {\r\n    return clone\r\n  }\r\n\r\n  const processedDefs: { [key: string]: HTMLElement } = {}\r\n  for (let i = 0; i < uses.length; i++) {\r\n    const use = uses[i]\r\n    const id = use.getAttribute('xlink:href')\r\n    if (id) {\r\n      const exist = clone.querySelector(id)\r\n      const definition = document.querySelector(id) as HTMLElement\r\n      if (!exist && definition && !processedDefs[id]) {\r\n        // eslint-disable-next-line no-await-in-loop\r\n        processedDefs[id] = (await cloneNode(definition, options, true))!\r\n      }\r\n    }\r\n  }\r\n\r\n  const nodes = Object.values(processedDefs)\r\n  if (nodes.length) {\r\n    const ns = 'http://www.w3.org/1999/xhtml'\r\n    const svg = document.createElementNS(ns, 'svg')\r\n    svg.setAttribute('xmlns', ns)\r\n    svg.style.position = 'absolute'\r\n    svg.style.width = '0'\r\n    svg.style.height = '0'\r\n    svg.style.overflow = 'hidden'\r\n    svg.style.display = 'none'\r\n\r\n    const defs = document.createElementNS(ns, 'defs')\r\n    svg.appendChild(defs)\r\n\r\n    for (let i = 0; i < nodes.length; i++) {\r\n      defs.appendChild(nodes[i])\r\n    }\r\n\r\n    clone.appendChild(svg)\r\n  }\r\n\r\n  return clone\r\n}\r\n\r\nexport async function cloneNode<T extends HTMLElement>(\r\n  node: T,\r\n  options: Options,\r\n  isRoot?: boolean,\r\n): Promise<T | null> {\r\n  if (!isRoot && options.filter && !options.filter(node)) {\r\n    return null\r\n  }\r\n\r\n  return Promise.resolve(node)\r\n    .then((clonedNode) => cloneSingleNode(clonedNode, options) as Promise<T>)\r\n    .then((clonedNode) => cloneChildren(node, clonedNode, options))\r\n    .then((clonedNode) => decorate(node, clonedNode, options))\r\n    .then((clonedNode) => ensureSVGSymbols(clonedNode, options))\r\n}\r\n", "import { Options } from './types'\r\nimport { resolveUrl } from './util'\r\nimport { getMimeType } from './mimes'\r\nimport { isDataUrl, makeDataUrl, resourceToDataURL } from './dataurl'\r\n\r\nconst URL_REGEX = /url\\((['\"]?)([^'\"]+?)\\1\\)/g\r\nconst URL_WITH_FORMAT_REGEX = /url\\([^)]+\\)\\s*format\\(([\"']?)([^\"']+)\\1\\)/g\r\nconst FONT_SRC_REGEX = /src:\\s*(?:url\\([^)]+\\)\\s*format\\([^)]+\\)[,;]\\s*)+/g\r\n\r\nfunction toRegex(url: string): RegExp {\r\n  // eslint-disable-next-line no-useless-escape\r\n  const escaped = url.replace(/([.*+?^${}()|\\[\\]\\/\\\\])/g, '\\\\$1')\r\n  return new RegExp(`(url\\\\(['\"]?)(${escaped})(['\"]?\\\\))`, 'g')\r\n}\r\n\r\nexport function parseURLs(cssText: string): string[] {\r\n  const urls: string[] = []\r\n\r\n  cssText.replace(URL_REGEX, (raw, quotation, url) => {\r\n    urls.push(url)\r\n    return raw\r\n  })\r\n\r\n  return urls.filter((url) => !isDataUrl(url))\r\n}\r\n\r\nexport async function embed(\r\n  cssText: string,\r\n  resourceURL: string,\r\n  baseURL: string | null,\r\n  options: Options,\r\n  getContentFromUrl?: (url: string) => Promise<string>,\r\n): Promise<string> {\r\n  try {\r\n    const resolvedURL = baseURL ? resolveUrl(resourceURL, baseURL) : resourceURL\r\n    const contentType = getMimeType(resourceURL)\r\n    let dataURL: string\r\n    if (getContentFromUrl) {\r\n      const content = await getContentFromUrl(resolvedURL)\r\n      dataURL = makeDataUrl(content, contentType)\r\n    } else {\r\n      dataURL = await resourceToDataURL(resolvedURL, contentType, options)\r\n    }\r\n    return cssText.replace(toRegex(resourceURL), `$1${dataURL}$3`)\r\n  } catch (error) {\r\n    // pass\r\n  }\r\n  return cssText\r\n}\r\n\r\nfunction filterPreferredFontFormat(\r\n  str: string,\r\n  { preferredFontFormat }: Options,\r\n): string {\r\n  return !preferredFontFormat\r\n    ? str\r\n    : str.replace(FONT_SRC_REGEX, (match: string) => {\r\n        // eslint-disable-next-line no-constant-condition\r\n        while (true) {\r\n          const [src, , format] = URL_WITH_FORMAT_REGEX.exec(match) || []\r\n          if (!format) {\r\n            return ''\r\n          }\r\n\r\n          if (format === preferredFontFormat) {\r\n            return `src: ${src};`\r\n          }\r\n        }\r\n      })\r\n}\r\n\r\nexport function shouldEmbed(url: string): boolean {\r\n  return url.search(URL_REGEX) !== -1\r\n}\r\n\r\nexport async function embedResources(\r\n  cssText: string,\r\n  baseUrl: string | null,\r\n  options: Options,\r\n): Promise<string> {\r\n  if (!shouldEmbed(cssText)) {\r\n    return cssText\r\n  }\r\n\r\n  const filteredCSSText = filterPreferredFontFormat(cssText, options)\r\n  const urls = parseURLs(filteredCSSText)\r\n  return urls.reduce(\r\n    (deferred, url) =>\r\n      deferred.then((css) => embed(css, url, baseUrl, options)),\r\n    Promise.resolve(filteredCSSText),\r\n  )\r\n}\r\n", "import { Options } from './types'\r\nimport { embedResources } from './embed-resources'\r\nimport { toArray, isInstanceOfElement } from './util'\r\nimport { isDataUrl, resourceToDataURL } from './dataurl'\r\nimport { getMimeType } from './mimes'\r\n\r\nasync function embedProp(\r\n  propName: string,\r\n  node: HTMLElement,\r\n  options: Options,\r\n) {\r\n  const propValue = node.style?.getPropertyValue(propName)\r\n  if (propValue) {\r\n    const cssString = await embedResources(propValue, null, options)\r\n    node.style.setProperty(\r\n      propName,\r\n      cssString,\r\n      node.style.getPropertyPriority(propName),\r\n    )\r\n    return true\r\n  }\r\n  return false\r\n}\r\n\r\nasync function embedBackground<T extends HTMLElement>(\r\n  clonedNode: T,\r\n  options: Options,\r\n) {\r\n  ;(await embedProp('background', clonedNode, options)) ||\r\n    (await embedProp('background-image', clonedNode, options))\r\n  ;(await embedProp('mask', clonedNode, options)) ||\r\n    (await embedProp('-webkit-mask', clonedNode, options)) ||\r\n    (await embedProp('mask-image', clonedNode, options)) ||\r\n    (await embedProp('-webkit-mask-image', clonedNode, options))\r\n}\r\n\r\nasync function embedImageNode<T extends HTMLElement | SVGImageElement>(\r\n  clonedNode: T,\r\n  options: Options,\r\n) {\r\n  const isImageElement = isInstanceOfElement(clonedNode, HTMLImageElement)\r\n\r\n  if (\r\n    !(isImageElement && !isDataUrl(clonedNode.src)) &&\r\n    !(\r\n      isInstanceOfElement(clonedNode, SVGImageElement) &&\r\n      !isDataUrl(clonedNode.href.baseVal)\r\n    )\r\n  ) {\r\n    return\r\n  }\r\n\r\n  const url = isImageElement ? clonedNode.src : clonedNode.href.baseVal\r\n\r\n  const dataURL = await resourceToDataURL(url, getMimeType(url), options)\r\n  await new Promise((resolve, reject) => {\r\n    clonedNode.onload = resolve\r\n    clonedNode.onerror = options.onImageErrorHandler\r\n      ? (...attributes) => {\r\n          try {\r\n            resolve(options.onImageErrorHandler!(...attributes))\r\n          } catch (error) {\r\n            reject(error)\r\n          }\r\n        }\r\n      : reject\r\n\r\n    const image = clonedNode as HTMLImageElement\r\n    if (image.decode) {\r\n      image.decode = resolve as any\r\n    }\r\n\r\n    if (image.loading === 'lazy') {\r\n      image.loading = 'eager'\r\n    }\r\n\r\n    if (isImageElement) {\r\n      clonedNode.srcset = ''\r\n      clonedNode.src = dataURL\r\n    } else {\r\n      clonedNode.href.baseVal = dataURL\r\n    }\r\n  })\r\n}\r\n\r\nasync function embedChildren<T extends HTMLElement>(\r\n  clonedNode: T,\r\n  options: Options,\r\n) {\r\n  const children = toArray<HTMLElement>(clonedNode.childNodes)\r\n  const deferreds = children.map((child) => embedImages(child, options))\r\n  await Promise.all(deferreds).then(() => clonedNode)\r\n}\r\n\r\nexport async function embedImages<T extends HTMLElement>(\r\n  clonedNode: T,\r\n  options: Options,\r\n) {\r\n  if (isInstanceOfElement(clonedNode, Element)) {\r\n    await embedBackground(clonedNode, options)\r\n    await embedImageNode(clonedNode, options)\r\n    await embedChildren(clonedNode, options)\r\n  }\r\n}\r\n", "import type { Options } from './types'\r\n\r\nexport function applyStyle<T extends HTMLElement>(\r\n  node: T,\r\n  options: Options,\r\n): T {\r\n  const { style } = node\r\n\r\n  if (options.backgroundColor) {\r\n    style.backgroundColor = options.backgroundColor\r\n  }\r\n\r\n  if (options.width) {\r\n    style.width = `${options.width}px`\r\n  }\r\n\r\n  if (options.height) {\r\n    style.height = `${options.height}px`\r\n  }\r\n\r\n  const manual = options.style\r\n  if (manual != null) {\r\n    Object.keys(manual).forEach((key: any) => {\r\n      style[key] = manual[key] as string\r\n    })\r\n  }\r\n\r\n  return node\r\n}\r\n", "import type { Options } from './types'\r\nimport { toArray } from './util'\r\nimport { fetchAsDataURL } from './dataurl'\r\nimport { shouldEmbed, embedResources } from './embed-resources'\r\n\r\ninterface Metadata {\r\n  url: string\r\n  cssText: string\r\n}\r\n\r\nconst cssFetchCache: { [href: string]: Metadata } = {}\r\n\r\nasync function fetchCSS(url: string) {\r\n  let cache = cssFetchCache[url]\r\n  if (cache != null) {\r\n    return cache\r\n  }\r\n\r\n  const res = await fetch(url)\r\n  const cssText = await res.text()\r\n  cache = { url, cssText }\r\n\r\n  cssFetchCache[url] = cache\r\n\r\n  return cache\r\n}\r\n\r\nasync function embedFonts(data: Metadata, options: Options): Promise<string> {\r\n  let cssText = data.cssText\r\n  const regexUrl = /url\\([\"']?([^\"')]+)[\"']?\\)/g\r\n  const fontLocs = cssText.match(/url\\([^)]+\\)/g) || []\r\n  const loadFonts = fontLocs.map(async (loc: string) => {\r\n    let url = loc.replace(regexUrl, '$1')\r\n    if (!url.startsWith('https://')) {\r\n      url = new URL(url, data.url).href\r\n    }\r\n\r\n    return fetchAsDataURL<[string, string]>(\r\n      url,\r\n      options.fetchRequestInit,\r\n      ({ result }) => {\r\n        cssText = cssText.replace(loc, `url(${result})`)\r\n        return [loc, result]\r\n      },\r\n    )\r\n  })\r\n\r\n  return Promise.all(loadFonts).then(() => cssText)\r\n}\r\n\r\nfunction parseCSS(source: string) {\r\n  if (source == null) {\r\n    return []\r\n  }\r\n\r\n  const result: string[] = []\r\n  const commentsRegex = /(\\/\\*[\\s\\S]*?\\*\\/)/gi\r\n  // strip out comments\r\n  let cssText = source.replace(commentsRegex, '')\r\n\r\n  // eslint-disable-next-line prefer-regex-literals\r\n  const keyframesRegex = new RegExp(\r\n    '((@.*?keyframes [\\\\s\\\\S]*?){([\\\\s\\\\S]*?}\\\\s*?)})',\r\n    'gi',\r\n  )\r\n\r\n  // eslint-disable-next-line no-constant-condition\r\n  while (true) {\r\n    const matches = keyframesRegex.exec(cssText)\r\n    if (matches === null) {\r\n      break\r\n    }\r\n    result.push(matches[0])\r\n  }\r\n  cssText = cssText.replace(keyframesRegex, '')\r\n\r\n  const importRegex = /@import[\\s\\S]*?url\\([^)]*\\)[\\s\\S]*?;/gi\r\n  // to match css & media queries together\r\n  const combinedCSSRegex =\r\n    '((\\\\s*?(?:\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\/)?\\\\s*?@media[\\\\s\\\\S]' +\r\n    '*?){([\\\\s\\\\S]*?)}\\\\s*?})|(([\\\\s\\\\S]*?){([\\\\s\\\\S]*?)})'\r\n  // unified regex\r\n  const unifiedRegex = new RegExp(combinedCSSRegex, 'gi')\r\n\r\n  // eslint-disable-next-line no-constant-condition\r\n  while (true) {\r\n    let matches = importRegex.exec(cssText)\r\n    if (matches === null) {\r\n      matches = unifiedRegex.exec(cssText)\r\n      if (matches === null) {\r\n        break\r\n      } else {\r\n        importRegex.lastIndex = unifiedRegex.lastIndex\r\n      }\r\n    } else {\r\n      unifiedRegex.lastIndex = importRegex.lastIndex\r\n    }\r\n    result.push(matches[0])\r\n  }\r\n\r\n  return result\r\n}\r\n\r\nasync function getCSSRules(\r\n  styleSheets: CSSStyleSheet[],\r\n  options: Options,\r\n): Promise<CSSStyleRule[]> {\r\n  const ret: CSSStyleRule[] = []\r\n  const deferreds: Promise<number | void>[] = []\r\n\r\n  // First loop inlines imports\r\n  styleSheets.forEach((sheet) => {\r\n    if ('cssRules' in sheet) {\r\n      try {\r\n        toArray<CSSRule>(sheet.cssRules || []).forEach((item, index) => {\r\n          if (item.type === CSSRule.IMPORT_RULE) {\r\n            let importIndex = index + 1\r\n            const url = (item as CSSImportRule).href\r\n            const deferred = fetchCSS(url)\r\n              .then((metadata) => embedFonts(metadata, options))\r\n              .then((cssText) =>\r\n                parseCSS(cssText).forEach((rule) => {\r\n                  try {\r\n                    sheet.insertRule(\r\n                      rule,\r\n                      rule.startsWith('@import')\r\n                        ? (importIndex += 1)\r\n                        : sheet.cssRules.length,\r\n                    )\r\n                  } catch (error) {\r\n                    console.error('Error inserting rule from remote css', {\r\n                      rule,\r\n                      error,\r\n                    })\r\n                  }\r\n                }),\r\n              )\r\n              .catch((e) => {\r\n                console.error('Error loading remote css', e.toString())\r\n              })\r\n\r\n            deferreds.push(deferred)\r\n          }\r\n        })\r\n      } catch (e) {\r\n        const inline =\r\n          styleSheets.find((a) => a.href == null) || document.styleSheets[0]\r\n        if (sheet.href != null) {\r\n          deferreds.push(\r\n            fetchCSS(sheet.href)\r\n              .then((metadata) => embedFonts(metadata, options))\r\n              .then((cssText) =>\r\n                parseCSS(cssText).forEach((rule) => {\r\n                  inline.insertRule(rule, inline.cssRules.length)\r\n                }),\r\n              )\r\n              .catch((err: unknown) => {\r\n                console.error('Error loading remote stylesheet', err)\r\n              }),\r\n          )\r\n        }\r\n        console.error('Error inlining remote css file', e)\r\n      }\r\n    }\r\n  })\r\n\r\n  return Promise.all(deferreds).then(() => {\r\n    // Second loop parses rules\r\n    styleSheets.forEach((sheet) => {\r\n      if ('cssRules' in sheet) {\r\n        try {\r\n          toArray<CSSStyleRule>(sheet.cssRules || []).forEach((item) => {\r\n            ret.push(item)\r\n          })\r\n        } catch (e) {\r\n          console.error(`Error while reading CSS rules from ${sheet.href}`, e)\r\n        }\r\n      }\r\n    })\r\n\r\n    return ret\r\n  })\r\n}\r\n\r\nfunction getWebFontRules(cssRules: CSSStyleRule[]): CSSStyleRule[] {\r\n  return cssRules\r\n    .filter((rule) => rule.type === CSSRule.FONT_FACE_RULE)\r\n    .filter((rule) => shouldEmbed(rule.style.getPropertyValue('src')))\r\n}\r\n\r\nasync function parseWebFontRules<T extends HTMLElement>(\r\n  node: T,\r\n  options: Options,\r\n) {\r\n  if (node.ownerDocument == null) {\r\n    throw new Error('Provided element is not within a Document')\r\n  }\r\n\r\n  const styleSheets = toArray<CSSStyleSheet>(node.ownerDocument.styleSheets)\r\n  const cssRules = await getCSSRules(styleSheets, options)\r\n\r\n  return getWebFontRules(cssRules)\r\n}\r\n\r\nfunction normalizeFontFamily(font: string) {\r\n  return font.trim().replace(/[\"']/g, '')\r\n}\r\n\r\nfunction getUsedFonts(node: HTMLElement) {\r\n  const fonts = new Set<string>()\r\n  function traverse(node: HTMLElement) {\r\n    const fontFamily =\r\n      node.style.fontFamily || getComputedStyle(node).fontFamily\r\n    fontFamily.split(',').forEach((font) => {\r\n      fonts.add(normalizeFontFamily(font))\r\n    })\r\n\r\n    Array.from(node.children).forEach((child) => {\r\n      if (child instanceof HTMLElement) {\r\n        traverse(child)\r\n      }\r\n    })\r\n  }\r\n  traverse(node)\r\n  return fonts\r\n}\r\n\r\nexport async function getWebFontCSS<T extends HTMLElement>(\r\n  node: T,\r\n  options: Options,\r\n): Promise<string> {\r\n  const rules = await parseWebFontRules(node, options)\r\n  const usedFonts = getUsedFonts(node)\r\n  const cssTexts = await Promise.all(\r\n    rules\r\n      .filter((rule) =>\r\n        usedFonts.has(normalizeFontFamily(rule.style.fontFamily)),\r\n      )\r\n      .map((rule) => {\r\n        const baseUrl = rule.parentStyleSheet\r\n          ? rule.parentStyleSheet.href\r\n          : null\r\n        return embedResources(rule.cssText, baseUrl, options)\r\n      }),\r\n  )\r\n\r\n  return cssTexts.join('\\n')\r\n}\r\n\r\nexport async function embedWebFonts<T extends HTMLElement>(\r\n  clonedNode: T,\r\n  options: Options,\r\n) {\r\n  const cssText =\r\n    options.fontEmbedCSS != null\r\n      ? options.fontEmbedCSS\r\n      : options.skipFonts\r\n      ? null\r\n      : await getWebFontCSS(clonedNode, options)\r\n\r\n  if (cssText) {\r\n    const styleNode = document.createElement('style')\r\n    const sytleContent = document.createTextNode(cssText)\r\n\r\n    styleNode.appendChild(sytleContent)\r\n\r\n    if (clonedNode.firstChild) {\r\n      clonedNode.insertBefore(styleNode, clonedNode.firstChild)\r\n    } else {\r\n      clonedNode.appendChild(styleNode)\r\n    }\r\n  }\r\n}\r\n", "import { Options } from './types'\r\nimport { cloneNode } from './clone-node'\r\nimport { embedImages } from './embed-images'\r\nimport { applyStyle } from './apply-style'\r\nimport { embedWebFonts, getWebFontCSS } from './embed-webfonts'\r\nimport {\r\n  getImageSize,\r\n  getPixelRatio,\r\n  createImage,\r\n  canvasToBlob,\r\n  nodeToDataURL,\r\n  checkCanvasDimensions,\r\n} from './util'\r\n\r\nexport async function toSvg<T extends HTMLElement>(\r\n  node: T,\r\n  options: Options = {},\r\n): Promise<string> {\r\n  const { width, height } = getImageSize(node, options)\r\n  const clonedNode = (await cloneNode(node, options, true)) as HTMLElement\r\n  await embedWebFonts(clonedNode, options)\r\n  await embedImages(clonedNode, options)\r\n  applyStyle(clonedNode, options)\r\n  const datauri = await nodeToDataURL(clonedNode, width, height)\r\n  return datauri\r\n}\r\n\r\nexport async function toCanvas<T extends HTMLElement>(\r\n  node: T,\r\n  options: Options = {},\r\n): Promise<HTMLCanvasElement> {\r\n  const { width, height } = getImageSize(node, options)\r\n  const svg = await toSvg(node, options)\r\n  const img = await createImage(svg)\r\n\r\n  const canvas = document.createElement('canvas')\r\n  const context = canvas.getContext('2d')!\r\n  const ratio = options.pixelRatio || getPixelRatio()\r\n  const canvasWidth = options.canvasWidth || width\r\n  const canvasHeight = options.canvasHeight || height\r\n\r\n  canvas.width = canvasWidth * ratio\r\n  canvas.height = canvasHeight * ratio\r\n\r\n  if (!options.skipAutoScale) {\r\n    checkCanvasDimensions(canvas)\r\n  }\r\n  canvas.style.width = `${canvasWidth}`\r\n  canvas.style.height = `${canvasHeight}`\r\n\r\n  if (options.backgroundColor) {\r\n    context.fillStyle = options.backgroundColor\r\n    context.fillRect(0, 0, canvas.width, canvas.height)\r\n  }\r\n\r\n  context.drawImage(img, 0, 0, canvas.width, canvas.height)\r\n\r\n  return canvas\r\n}\r\n\r\nexport async function toPixelData<T extends HTMLElement>(\r\n  node: T,\r\n  options: Options = {},\r\n): Promise<Uint8ClampedArray> {\r\n  const { width, height } = getImageSize(node, options)\r\n  const canvas = await toCanvas(node, options)\r\n  const ctx = canvas.getContext('2d')!\r\n  return ctx.getImageData(0, 0, width, height).data\r\n}\r\n\r\nexport async function toPng<T extends HTMLElement>(\r\n  node: T,\r\n  options: Options = {},\r\n): Promise<string> {\r\n  const canvas = await toCanvas(node, options)\r\n  return canvas.toDataURL()\r\n}\r\n\r\nexport async function toJpeg<T extends HTMLElement>(\r\n  node: T,\r\n  options: Options = {},\r\n): Promise<string> {\r\n  const canvas = await toCanvas(node, options)\r\n  return canvas.toDataURL('image/jpeg', options.quality || 1)\r\n}\r\n\r\nexport async function toBlob<T extends HTMLElement>(\r\n  node: T,\r\n  options: Options = {},\r\n): Promise<Blob | null> {\r\n  const canvas = await toCanvas(node, options)\r\n  const blob = await canvasToBlob(canvas)\r\n  return blob\r\n}\r\n\r\nexport async function getFontEmbedCSS<T extends HTMLElement>(\r\n  node: T,\r\n  options: Options = {},\r\n): Promise<string> {\r\n  return getWebFontCSS(node, options)\r\n}\r\n"],
  "mappings": "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",
  "names": ["process", "dataURL", "cache", "node"]
}
